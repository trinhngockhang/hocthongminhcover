import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';
import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _get from 'babel-runtime/helpers/get';
import _inherits from 'babel-runtime/helpers/inherits';
import AnalyticsEvent from './AnalyticsEvent';
var _console = console,
    warn = _console.warn;

var UIAnalyticsEvent = function (_AnalyticsEvent) {
  _inherits(UIAnalyticsEvent, _AnalyticsEvent);

  function UIAnalyticsEvent(props) {
    _classCallCheck(this, UIAnalyticsEvent);

    var _this = _possibleConstructorReturn(this, (UIAnalyticsEvent.__proto__ || _Object$getPrototypeOf(UIAnalyticsEvent)).call(this, props));

    _this.clone = function () {
      if (_this.hasFired) {
        warn("Cannot clone an event after it's been fired.");
        return null;
      }
      var context = [].concat(_toConsumableArray(_this.context));
      var handlers = [].concat(_toConsumableArray(_this.handlers));

      // We stringify and parse here to get a hacky "deep clone" of the object.
      // This has some limitations in that it wont support functions, regexs, Maps, Sets, etc,
      // but none of those need to be represented in our payload, so we consider this fine
      var payload = JSON.parse(_JSON$stringify(_this.payload));

      return new UIAnalyticsEvent({ context: context, handlers: handlers, payload: payload });
    };

    _this.fire = function (channel) {
      if (_this.hasFired) {
        warn('Cannot fire an event twice.');
        return;
      }
      _this.handlers.forEach(function (handler) {
        handler(_this, channel);
      });
      _this.hasFired = true;
    };

    _this.context = props.context || [];
    _this.handlers = props.handlers || [];
    _this.hasFired = false;
    return _this;
  }

  _createClass(UIAnalyticsEvent, [{
    key: 'update',
    value: function update(updater) {
      if (this.hasFired) {
        warn("Cannot update an event after it's been fired.");
        return this;
      }
      return _get(UIAnalyticsEvent.prototype.__proto__ || _Object$getPrototypeOf(UIAnalyticsEvent.prototype), 'update', this).call(this, updater);
    }
  }]);

  return UIAnalyticsEvent;
}(AnalyticsEvent);

export default UIAnalyticsEvent;