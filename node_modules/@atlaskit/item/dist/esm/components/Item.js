import _extends from 'babel-runtime/helpers/extends';
import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';
import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React, { Component } from 'react';

import styledRootElement from '../styled/Item';
import { Before, After, Content, ContentWrapper, Description } from '../styled/ItemParts';

var Item = function (_Component) {
  _inherits(Item, _Component);

  function Item(props) {
    _classCallCheck(this, Item);

    // The type of element rendered at the root of render() can vary based on the `href`
    // and `linkComponent` props provided. We generate this component here to avoid re-
    // generating the component inside render(). This is for performance reasons, and also
    // allows us to avoid generating a new `ref` for the root element each render().
    var _this = _possibleConstructorReturn(this, (Item.__proto__ || _Object$getPrototypeOf(Item)).call(this, props));

    _this.setRef = function (ref) {
      _this.ref = ref;
    };

    _this.href = function () {
      return _this.props.isDisabled ? null : _this.props.href;
    };

    _this.rootComponent = styledRootElement({
      href: _this.href(),
      linkComponent: props.linkComponent
    });
    return _this;
  }
  // eslint-disable-next-line react/sort-comp


  _createClass(Item, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (this.ref && this.props.autoFocus) {
        this.ref.focus();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          onClick = _props.onClick,
          onKeyDown = _props.onKeyDown,
          isCompact = _props.isCompact,
          isDisabled = _props.isDisabled,
          isDragging = _props.isDragging,
          isHidden = _props.isHidden,
          isSelected = _props.isSelected,
          onMouseEnter = _props.onMouseEnter,
          onMouseLeave = _props.onMouseLeave,
          role = _props.role,
          dnd = _props.dnd,
          otherProps = _objectWithoutProperties(_props, ['onClick', 'onKeyDown', 'isCompact', 'isDisabled', 'isDragging', 'isHidden', 'isSelected', 'onMouseEnter', 'onMouseLeave', 'role', 'dnd']);

      var Root = this.rootComponent;

      var dragHandleProps = dnd && dnd.dragHandleProps || null;

      var patchedEventHandlers = {
        onClick: function (_onClick) {
          function onClick(_x) {
            return _onClick.apply(this, arguments);
          }

          onClick.toString = function () {
            return _onClick.toString();
          };

          return onClick;
        }(function (event) {
          var original = function original() {
            if (!isDisabled && onClick) {
              onClick(event);
            }
          };

          if (!dragHandleProps || !dragHandleProps.onClick) {
            original();
            return;
          }

          // Drag and drop has its own disabled mechansim
          // So not checking for isDisabled
          dragHandleProps.onClick(event);

          // if default is prevent - do not fire the onClick prop
          if (event.defaultPrevented) {
            return;
          }

          original();
        }),
        onMouseDown: function onMouseDown(event) {
          if (dragHandleProps && dragHandleProps.onMouseDown) {
            dragHandleProps.onMouseDown(event);
          }

          // We want to prevent the item from getting focus when clicked
          event.preventDefault();
        },
        onKeyDown: function (_onKeyDown) {
          function onKeyDown(_x2) {
            return _onKeyDown.apply(this, arguments);
          }

          onKeyDown.toString = function () {
            return _onKeyDown.toString();
          };

          return onKeyDown;
        }(function (event) {
          var original = function original() {
            if (!isDisabled && onKeyDown) {
              onKeyDown(event);
            }
          };

          if (!dragHandleProps || !dragHandleProps.onKeyDown) {
            original();
            return;
          }

          dragHandleProps.onKeyDown(event);

          // if default is prevent - do not fire other handlers
          if (event.defaultPrevented) {
            return;
          }

          // not allowing keyboard events on the element while dragging
          if (isDragging) {
            return;
          }

          original();
        })
      };

      var patchedInnerRef = function patchedInnerRef(ref) {
        _this2.setRef(ref);

        if (dnd && dnd.innerRef) {
          dnd.innerRef(ref);
        }
      };

      return React.createElement(
        Root,
        _extends({
          'aria-disabled': isDisabled,
          href: this.href(),
          isCompact: isCompact,
          isDisabled: isDisabled,
          isDragging: isDragging,
          isHidden: isHidden,
          isSelected: isSelected,
          onMouseEnter: onMouseEnter,
          onMouseLeave: onMouseLeave,
          role: role,
          tabIndex: isDisabled || isHidden || this.props.href ? null : 0,
          target: this.props.target,
          title: this.props.title,
          style: dnd ? dnd.draggableStyle : null,
          innerRef: patchedInnerRef
        }, dragHandleProps, patchedEventHandlers, otherProps),
        !!this.props.elemBefore && React.createElement(
          Before,
          { isCompact: isCompact },
          this.props.elemBefore
        ),
        React.createElement(
          ContentWrapper,
          null,
          React.createElement(
            Content,
            { allowMultiline: this.props.shouldAllowMultiline },
            this.props.children
          ),
          !!this.props.description && React.createElement(
            Description,
            {
              isCompact: this.props.isCompact,
              isDisabled: this.props.isDisabled
            },
            this.props.description
          )
        ),
        !!this.props.elemAfter && React.createElement(
          After,
          { isCompact: isCompact },
          this.props.elemAfter
        )
      );
    }
  }]);

  return Item;
}(Component);

Item.defaultProps = {
  autoFocus: false,
  description: '',
  isCompact: false,
  isDisabled: false,
  isHidden: false,
  role: 'button',
  shouldAllowMultiline: false
};
export default Item;