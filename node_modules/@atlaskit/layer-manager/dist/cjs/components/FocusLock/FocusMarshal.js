'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _tabbable = require('tabbable');

var _tabbable2 = _interopRequireDefault(_tabbable);

var _focusin = require('focusin');

var _focusin2 = _interopRequireDefault(_focusin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FocusLockRegistry = function () {
  function FocusLockRegistry() {
    var _this = this;

    (0, _classCallCheck3.default)(this, FocusLockRegistry);
    this.currentLock = null;
    this.isPolyfilled = false;
    this.storedElements = [];

    this.storeFocus = function () {
      var activeEl = document.activeElement;

      if (activeEl) _this.storedElements.push(activeEl);
    };

    this.clearStoredFocus = function () {
      _this.storedElements = [];
    };

    this.restoreFocus = function () {
      if (!_this.storedElements.length) return;

      try {
        var target = _this.storedElements[_this.storedElements.length - 1];

        if (target && typeof target.focus === 'function') {
          target.focus();
        }
      } catch (err) {
        if (process.env.NODE_ENV !== 'production') {
          console.error(err); // eslint-disable-line no-console
        }
      }

      _this.storedElements.pop();
    };

    this.handleFocus = function () {
      if (_this.focusTarget) _this.focusTarget.focus();
    };

    this.handleFocusIn = function (event) {
      var target = event.target;

      if (!(target instanceof HTMLElement)) return;

      var shouldFocus = _this.currentLock && _this.currentLock !== target && !_this.currentLock.contains(target);

      if (shouldFocus) _this.handleFocus();
    };

    this.handleKeyDown = function (_ref) {
      var key = _ref.key,
          shiftKey = _ref.shiftKey,
          target = _ref.target,
          preventDefault = _ref.preventDefault;

      if (key !== 'Tab') return;

      var els = (0, _tabbable2.default)(_this.currentLock);
      var first = els[0];
      var last = els[els.length - 1];

      if (target === last && !shiftKey) {
        preventDefault();
        first.focus();
      }
    };
  } // numeric string


  (0, _createClass3.default)(FocusLockRegistry, [{
    key: 'polyfillFocusIn',


    // lazily polyfill focusin for firefox
    value: function polyfillFocusIn() {
      if (this.isPolyfilled) return;

      _focusin2.default.polyfill();
      this.isPolyfilled = true;
    }

    // ==============================
    // Registry
    // ==============================

  }, {
    key: 'addLock',
    value: function addLock(_ref2) {
      var autoFocus = _ref2.autoFocus,
          boundary = _ref2.boundary;

      // NOTE: Only one element can be focused at a time.
      // Teardown all instances of FocusLock before another
      // initialises (mounts or becomes `enabled`).
      this.clearLock({ shouldRestoreFocus: false });

      // store the last activeElement
      this.storeFocus();

      this.currentLock = boundary;
      this.focusTarget = this.findFocusTarget(autoFocus);

      document.addEventListener('focusin', this.handleFocusIn);
      document.addEventListener('keydown', this.handleKeyDown);

      // ensure that "focusin" has something to focus
      if (boundary && !autoFocus) {
        this.originalTabindex = boundary.getAttribute('tabindex') || '';

        // catch negative indexes
        var idx = parseInt(this.originalTabindex, 10);
        if (!idx || idx && idx < 0) boundary.setAttribute('tabindex', '0');
      }

      // initial focus call
      this.handleFocus();
    }
  }, {
    key: 'clearLock',
    value: function clearLock(options) {
      document.removeEventListener('focusin', this.handleFocusIn);
      document.removeEventListener('keydown', this.handleKeyDown);

      // restore original tabindex if any
      if (this.currentLock && this.originalTabindex) {
        if (this.originalTabindex) {
          this.currentLock.setAttribute('tabindex', this.originalTabindex);
        } else {
          this.currentLock.removeAttribute('tabindex');
        }
      }

      if (options.shouldRestoreFocus) {
        this.restoreFocus();
      }

      this.currentLock = null;
    }
  }, {
    key: 'register',
    value: function register(_ref3) {
      var autoFocus = _ref3.autoFocus,
          boundary = _ref3.boundary;

      this.polyfillFocusIn();
      this.addLock({ autoFocus: autoFocus, boundary: boundary });
    }
  }, {
    key: 'unregister',
    value: function unregister(options) {
      this.clearLock(options);
    }

    // ==============================
    // Focus Store
    // ==============================

    // ==============================
    // Handlers
    // ==============================

    // catch focus if the target is outside the locked element


    // loop back to the first tabbable element from the last

  }, {
    key: 'findFocusTarget',
    value: function findFocusTarget(autoFocus) {
      var hasFocusFunc = typeof autoFocus === 'function';
      var focusFirstAvailable = autoFocus && !hasFocusFunc || false;
      var defaultTarget = this.currentLock;

      // get the first tabbable element e.g. anchor, button, [tabIndex >= 0]
      if (focusFirstAvailable) {
        var els = (0, _tabbable2.default)(this.currentLock);
        return els[0];
      }

      // call the consumer's ref function to get a target
      if (typeof autoFocus === 'function') {
        var focusTarget = autoFocus();

        // check that the provided focusTarget is what we expect, warn otherwise
        if (!focusTarget || typeof focusTarget.focus !== 'function') {
          console.warn('Invalid `autoFocus` provided:', focusTarget); // eslint-disable-line no-console
          return defaultTarget;
        }

        return focusTarget;
      }

      // if nothing can be found, allow focus on the boundary element itself
      return defaultTarget;
    }
  }]);
  return FocusLockRegistry;
}();

exports.default = FocusLockRegistry;