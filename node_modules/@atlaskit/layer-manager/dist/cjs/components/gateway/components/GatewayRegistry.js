'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _withContextFromProps = require('../../withContextFromProps');

var _withContextFromProps2 = _interopRequireDefault(_withContextFromProps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var contextTypes = {
  blockChildGatewayRender: _propTypes2.default.bool
};


var ContextProvider = (0, _withContextFromProps2.default)(contextTypes, null);

var GatewayRegistry = function () {
  function GatewayRegistry() {
    (0, _classCallCheck3.default)(this, GatewayRegistry);
    this.containers = {};
    this.children = {};
    this.currentId = 0;
  }

  (0, _createClass3.default)(GatewayRegistry, [{
    key: 'renderContainer',
    // Unique key for children of a gateway

    /**
     *   NOTE: this is where we deviate from cloudflare/react-gateway
     *   https://github.com/cloudflare/react-gateway/blob/master/src/GatewayRegistry.js#L10
     *
     *   Rather than passing children through directly, they're cloned with:
     *   - stackIndex
     *   - stackTotal
     */
    value: function renderContainer(name, addedGateway) {
      var _this = this;

      if (!this.containers[name] || !this.children[name]) {
        return;
      }

      var childrenKeys = (0, _keys2.default)(this.children[name]).sort();
      var stackTotal = childrenKeys.length;
      var addedGatewayIndex = childrenKeys.indexOf(addedGateway);

      this.containers[name].setState({
        children: childrenKeys.map(function (key, i) {
          var stackIndex = stackTotal - (i + 1);
          var element = (0, _react.cloneElement)(_this.children[name][key].child, {
            stackIndex: stackIndex,
            stackTotal: stackTotal
          });
          // Do not re-render nested gateways when a gateway is added to prevent an infinite loop
          // caused by an added gateway triggering a re-render of its parent and then itself.
          var blockChildGatewayRender = addedGateway != null && i < addedGatewayIndex;

          return _react2.default.createElement(
            ContextProvider,
            {
              blockChildGatewayRender: blockChildGatewayRender,
              key: key
            },
            element
          );
        })
      });
    }
  }, {
    key: 'addContainer',
    value: function addContainer(name, container) {
      this.containers[name] = container;
      this.renderContainer(name);
    }
  }, {
    key: 'removeContainer',
    value: function removeContainer(name) {
      this.containers[name] = null;
    }
  }, {
    key: 'addChild',
    value: function addChild(name, gatewayId, child) {
      this.children[name][gatewayId] = {
        child: child
      };
      this.renderContainer(name, gatewayId);
    }
  }, {
    key: 'clearChild',
    value: function clearChild(name, gatewayId) {
      delete this.children[name][gatewayId];
    }
  }, {
    key: 'register',
    value: function register(name, child) {
      this.children[name] = this.children[name] || {};

      var gatewayId = name + '_' + this.currentId;
      this.children[name][gatewayId] = {
        child: child
      };
      this.currentId += 1;

      return gatewayId;
    }
  }, {
    key: 'unregister',
    value: function unregister(name, gatewayId) {
      this.clearChild(name, gatewayId);
      this.renderContainer(name);
    }
  }]);
  return GatewayRegistry;
}();

exports.default = GatewayRegistry;