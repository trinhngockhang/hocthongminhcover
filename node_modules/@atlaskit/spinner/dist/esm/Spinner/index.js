import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import _taggedTemplateLiteral from 'babel-runtime/helpers/taggedTemplateLiteral';

var _templateObject = _taggedTemplateLiteral(['\n  display: inline-block;\n'], ['\n  display: inline-block;\n']);

import React, { Component } from 'react';
import { Transition } from 'react-transition-group';
import styled from 'styled-components';

import { SIZES_MAP, DEFAULT_SIZE } from './constants';
import Container from './styledContainer';
import Svg from './styledSvg';


var Outer = styled.div(_templateObject);
Outer.displayName = 'Outer';

var Spinner = function (_Component) {
  _inherits(Spinner, _Component);

  function Spinner(props) {
    _classCallCheck(this, Spinner);

    var _this = _possibleConstructorReturn(this, (Spinner.__proto__ || _Object$getPrototypeOf(Spinner)).call(this, props));

    _this.enter = function () {
      var delay = _this.props.delay;

      if (delay) {
        _this.setState({ phase: 'DELAY' });
      } else {
        _this.setState({ phase: 'ENTER' });
      }
    };

    _this.idle = function () {
      _this.setState({ phase: 'IDLE' });
    };

    _this.exit = function () {
      _this.setState({ phase: 'LEAVE' });
    };

    _this.endListener = function (node, done) {
      var executeCallback = function executeCallback(event) {
        // ignore animation events on the glyph
        if (event.target.tagName === 'svg') {
          return false;
        }
        if (_this.state.phase === 'DELAY') {
          _this.setState({ phase: 'ENTER' });
          _this.endListener(node, done);
        } else {
          done();
        }
        return node && node.removeEventListener('animationend', executeCallback);
      };
      return node && node.addEventListener('animationend', executeCallback);
    };

    _this.validateSize = function () {
      var size = _this.props.size;

      var spinnerSize = SIZES_MAP[size] || size;
      return typeof spinnerSize === 'number' ? spinnerSize : DEFAULT_SIZE;
    };

    _this.state = {
      phase: ''
    };
    return _this;
  }

  _createClass(Spinner, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var phase = this.state.phase;
      var _props = this.props,
          delay = _props.delay,
          invertColor = _props.invertColor,
          isCompleting = _props.isCompleting;

      var size = this.validateSize();

      var strokeWidth = Math.round(size / 10);
      var strokeRadius = size / 2 - strokeWidth / 2;
      return React.createElement(
        Outer,
        null,
        React.createElement(
          Transition,
          {
            addEndListener: this.endListener,
            appear: true,
            'in': !isCompleting,
            mountOnEnter: true,
            unmountOnExit: true,
            onEnter: this.enter,
            onEntered: this.idle,
            onExit: this.exit,
            onExited: function onExited() {
              return _this2.props.onComplete();
            },
            ref: function ref(node) {
              _this2.transitionNode = node;
            }
          },
          React.createElement(
            Container,
            { delay: delay / 1000, phase: phase, size: size },
            React.createElement(
              Svg,
              {
                focusable: 'false',
                height: size,
                invertColor: invertColor,
                phase: phase,
                size: size,
                viewBox: '0 0 ' + size + ' ' + size,
                width: size,
                xmlns: 'http://www.w3.org/2000/svg'
              },
              React.createElement('circle', { cx: size / 2, cy: size / 2, r: strokeRadius })
            )
          )
        )
      );
    }
  }]);

  return Spinner;
}(Component);

Spinner.defaultProps = {
  delay: 100,
  isCompleting: false,
  invertColor: false,
  onComplete: function onComplete() {},
  size: 'small'
};
export default Spinner;