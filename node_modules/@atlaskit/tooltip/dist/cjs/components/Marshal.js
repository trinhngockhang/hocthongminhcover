'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SHOW_DELAY = 300;
var HIDE_DELAY = 300;

var SCROLLABLE = /auto|scroll/;

function isScrollable(node) {
  var nodeStyle = (0, _utils.getStyle)(node);
  return SCROLLABLE.test(nodeStyle.overflow) || SCROLLABLE.test(nodeStyle.overflowX) || SCROLLABLE.test(nodeStyle.overflowY);
}

var TooltipMarshal = function () {
  function TooltipMarshal() {
    var _this = this;

    (0, _classCallCheck3.default)(this, TooltipMarshal);
    this.scrollListenerBound = false;

    this.handleScroll = function () {
      if (!_this.visibleTooltip) return;
      _this.hideTooltip(_this.visibleTooltip, { immediate: true });
    };
  }

  (0, _createClass3.default)(TooltipMarshal, [{
    key: 'show',
    value: function show(tooltip) {
      var _this2 = this;

      // if the tooltip is already queued for show, don't interfere
      if (this.queuedForShow === tooltip) return;

      // if another tooltip is queued for show, clear it out
      if (this.queuedForShow) {
        this.clearShowTimeout();
      }

      // if the tooltip is already visible, make sure it's not about to be hidden
      if (this.visibleTooltip === tooltip) {
        if (this.queuedForHide === tooltip) {
          this.clearHideTimeout();
        }
        return;
      }

      // if a tooltip is already visible, but is not the one that should be
      // displayed, immediately switch them
      if (this.visibleTooltip) {
        // the visible tooltip may be queued to be hidden; prevent that
        if (this.queuedForHide) {
          this.clearHideTimeout();
        }
        // immediately hide the old tooltip and show the new one
        this.showTooltip(tooltip, { immediate: true });
        return;
      }

      // if no tooltip is displayed, show the tooltip after a delay
      this.queuedForShow = tooltip;

      this.showTimeout = setTimeout(function () {
        _this2.showTooltip(tooltip, { immediate: false });
      }, SHOW_DELAY);
    }
  }, {
    key: 'showTooltip',
    value: function showTooltip(tooltip, options) {
      this.queuedForShow = null;
      this.showTimeout = null;
      if (this.visibleTooltip) {
        this.visibleTooltip.hide({ immediate: true });
      }
      this.visibleTooltip = tooltip;
      this.addScrollListener(tooltip);
      tooltip.show(options);
    }
  }, {
    key: 'clearShowTimeout',
    value: function clearShowTimeout() {
      if (this.showTimeout) {
        clearTimeout(this.showTimeout);
      }
      this.showTimeout = null;
    }
  }, {
    key: 'addScrollListener',
    value: function addScrollListener(tooltip) {
      if (this.scrollListenerBound) return;

      this.scrollListenerBound = true;

      if (tooltip.wrapper) {
        var parent = tooltip.wrapper.parentNode;

        while (parent) {
          if (parent.tagName === 'BODY') {
            window.addEventListener('scroll', this.handleScroll);
            break;
          } else if (isScrollable(parent)) {
            if (parent.addEventListener) {
              parent.addEventListener('scroll', this.handleScroll);
            }
            break;
          }

          parent = parent.parentNode;
        }
      }
    }
  }, {
    key: 'removeScrollListener',
    value: function removeScrollListener(tooltip) {
      if (!this.scrollListenerBound) return;

      this.scrollListenerBound = false;

      if (tooltip.wrapper) {
        var parent = tooltip.wrapper.parentNode;

        while (parent) {
          if (parent.tagName === 'BODY') {
            window.addEventListener('scroll', this.handleScroll);
            break;
          } else if (isScrollable(parent)) {
            parent.removeEventListener('scroll', this.handleScroll);
            break;
          }

          parent = parent.parentNode;
        }
      }
    }
  }, {
    key: 'hide',
    value: function hide(tooltip) {
      var _this3 = this;

      // if the tooltip is already queued for hide, don't interfere
      if (this.queuedForHide === tooltip) return;

      // if the tooltip is queued for show clear it
      if (this.queuedForShow === tooltip) {
        this.clearShowTimeout();
        this.queuedForShow = null;
        return;
      }

      // bail if not the visible tooltip
      if (this.visibleTooltip !== tooltip) return;

      // queue for hide, hide current, and cleanup
      this.queuedForHide = tooltip;

      this.hideTimeout = setTimeout(function () {
        _this3.hideTooltip(tooltip, { immediate: false });
      }, HIDE_DELAY);
    }
  }, {
    key: 'hideTooltip',
    value: function hideTooltip(tooltip, options) {
      this.queuedForHide = null;
      this.hideTimeout = null;
      if (!this.visibleTooltip) {
        return;
      }
      this.removeScrollListener(this.visibleTooltip);
      this.visibleTooltip = null;
      tooltip.hide(options);
    }
  }, {
    key: 'clearHideTimeout',
    value: function clearHideTimeout() {
      if (this.hideTimeout) {
        clearTimeout(this.hideTimeout);
      }
      this.queuedForHide = null;
    }
  }]);
  return TooltipMarshal;
}();

exports.default = TooltipMarshal;