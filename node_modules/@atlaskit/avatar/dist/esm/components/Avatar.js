import _extends from 'babel-runtime/helpers/extends';
import _typeof from 'babel-runtime/helpers/typeof';
import _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';
import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React, { Component } from 'react';

import Tooltip from '@atlaskit/tooltip';
import { validIconSizes, propsOmittedFromClickData } from './constants';
import Presence from './Presence';
import AvatarImage from './AvatarImage';
import Status from './Status';
import Outer, { PresenceWrapper, StatusWrapper } from '../styled/Avatar';
import { omit } from '../utils';
import { getProps, getStyledAvatar } from '../helpers';
import { mapProps, withPseudoState } from '../hoc';


var warn = function warn(message) {
  if (process.env.NODE_ENV !== 'production') {
    console.warn(message); // eslint-disable-line no-console
  }
};

var Avatar = function (_Component) {
  _inherits(Avatar, _Component);

  function Avatar() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Avatar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Avatar.__proto__ || _Object$getPrototypeOf(Avatar)).call.apply(_ref, [this].concat(args))), _this), _this.blur = function () {
      if (_this.ref) _this.ref.blur();
    }, _this.focus = function () {
      if (_this.ref) _this.ref.focus();
    }, _this.guardedClick = function (event) {
      var _this$props = _this.props,
          isDisabled = _this$props.isDisabled,
          onClick = _this$props.onClick;


      if (isDisabled || typeof onClick !== 'function') return;

      var item = omit.apply(undefined, [_this.props].concat(_toConsumableArray(propsOmittedFromClickData)));

      onClick({ item: item, event: event });
    }, _this.renderIcon = function () {
      var _this$props2 = _this.props,
          appearance = _this$props2.appearance,
          borderColor = _this$props2.borderColor,
          presence = _this$props2.presence,
          status = _this$props2.status;

      var showPresence = Boolean(presence);
      var showStatus = Boolean(status);

      // no icon needed
      if (!showStatus && !showPresence) {
        return null;
      }

      // cannot display both
      if (showStatus && showPresence) {
        warn('Avatar supports `presence` OR `status` properties, not both.');
        return null;
      }

      // only support particular sizes
      if (validIconSizes.indexOf(_this.props.size) === -1) {
        warn('Avatar size "' + String(_this.props.size) + '" does NOT support ' + (showPresence ? 'presence' : 'status'));
        return null;
      }

      // we can cast here because we already know that it is a valid icon size
      var size = _this.props.size;

      var indicator = function () {
        if (showPresence) {
          var customPresenceNode = (typeof presence === 'undefined' ? 'undefined' : _typeof(presence)) === 'object' ? presence : null;

          return React.createElement(
            PresenceWrapper,
            { appearance: appearance, size: size },
            React.createElement(
              Presence,
              {
                borderColor: borderColor,
                presence: !customPresenceNode && presence,
                size: size
              },
              customPresenceNode
            )
          );
        }

        // showStatus
        return React.createElement(
          StatusWrapper,
          { appearance: appearance, size: size },
          React.createElement(Status, { status: status, borderColor: borderColor, size: size })
        );
      }();

      return indicator;
    }, _this.setRef = function (ref) {
      _this.ref = ref;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  // expose blur/focus to consumers via ref


  // disallow click on disabled avatars
  // only return avatar data properties


  // enforce status / presence rules
  /* eslint-disable no-console */


  _createClass(Avatar, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          appearance = _props.appearance,
          enableTooltip = _props.enableTooltip,
          name = _props.name,
          size = _props.size,
          src = _props.src,
          stackIndex = _props.stackIndex;

      // distill props from context, props, and state

      var enhancedProps = getProps(this);

      // provide element type based on props
      // TODO: why not enhanced props?
      var Inner = getStyledAvatar(this.props);

      var AvatarNode = React.createElement(
        Outer,
        { size: size, stackIndex: stackIndex },
        React.createElement(
          Inner,
          _extends({
            innerRef: this.setRef
          }, enhancedProps, {
            onClick: this.guardedClick
          }),
          React.createElement(AvatarImage, {
            alt: name,
            appearance: appearance,
            size: size,
            src: src
          })
        ),
        this.renderIcon()
      );

      return enableTooltip && name ? React.createElement(
        Tooltip,
        { content: name },
        AvatarNode
      ) : AvatarNode;
    }
  }]);

  return Avatar;
}(Component);

/**
 *  1. Higher order components seem to ignore default properties. Mapping
 *     `appearance` explicity here circumvents the issue.
 *  2. The withPseudoState HOC should remain generic so rather than pass on
 *     `enableTooltip` we map it to `isInteractive`.
 *  3. Handle keyboard/mouse events and pass props to the wrapped component:
 *     - isActive
 *     - isFocus
 *     - isHover
 */


Avatar.defaultProps = {
  appearance: 'circle',
  enableTooltip: true,
  size: 'medium'
};
export default mapProps({
  appearance: function appearance(props) {
    return props.appearance || Avatar.defaultProps.appearance;
  }, // 1
  isInteractive: function isInteractive(props) {
    return props.enableTooltip || Avatar.defaultProps.enableTooltip;
  } // 2
})(withPseudoState(Avatar)); // 3